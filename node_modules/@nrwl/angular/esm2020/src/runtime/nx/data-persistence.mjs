import { Injectable } from '@angular/core';
import { ofType } from '@ngrx/effects';
import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { isObservable, of } from 'rxjs';
import { catchError, concatMap, filter, groupBy, map, mergeMap, switchMap, withLatestFrom, } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@ngrx/store";
import * as i2 from "@ngrx/effects";
/**
 *
 * @whatItDoes Handles pessimistic updates (updating the server first).
 *
 * Updating the server, when implemented naively, suffers from race conditions and poor error handling.
 *
 * `pessimisticUpdate` addresses these problems. It runs all fetches in order, which removes race conditions
 * and forces the developer to handle errors.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('UPDATE_TODO'),
 *       pessimisticUpdate({
 *         // provides an action
 *         run: (action: UpdateTodo) => {
 *           // update the backend first, and then dispatch an action that will
 *           // update the client side
 *           return this.backend.updateTodo(action.todo.id, action.todo).pipe(
 *             map((updated) => ({
 *               type: 'UPDATE_TODO_SUCCESS',
 *               todo: updated,
 *             }))
 *           );
 *         },
 *         onError: (action: UpdateTodo, error: any) => {
 *           // we don't need to undo the changes on the client side.
 *           // we can dispatch an error, or simply log the error here and return `null`
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * Note that if you don't return a new action from the run callback, you must set the dispatch property
 * of the effect to false, like this:
 *
 * ```typescript
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       //...
 *     ), { dispatch: false }
 *   );
 * }
 * ```
 *
 * @param opts
 */
export function pessimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 *
 * @whatItDoes Handles optimistic updates (updating the client first).
 *
 * It runs all fetches in order, which removes race conditions and forces the developer to handle errors.
 *
 * When using `optimisticUpdate`, in case of a failure, the developer has already updated the state locally,
 * so the developer must provide an undo action.
 *
 * The error handling must be done in the callback, or by means of the undo action.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('UPDATE_TODO'),
 *       optimisticUpdate({
 *         // provides an action
 *         run: (action: UpdateTodo) => {
 *           return this.backend.updateTodo(action.todo.id, action.todo).pipe(
 *             mapTo({
 *               type: 'UPDATE_TODO_SUCCESS',
 *             })
 *           );
 *         },
 *         undoAction: (action: UpdateTodo, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return {
 *             type: 'UNDO_TODO_UPDATE',
 *             todo: action.todo,
 *           };
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * Note that if you don't return a new action from the run callback, you must set the dispatch property
 * of the effect to false, like this:
 *
 * ```typescript
 * class TodoEffects {
 *   updateTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       //...
 *     ), { dispatch: false }
 *   );
 * }
 * ```
 *
 * @param opts
 */
export function optimisticUpdate(opts) {
    return (source) => {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
/**
 *
 * @whatItDoes Handles data fetching.
 *
 * Data fetching implemented naively suffers from race conditions and poor error handling.
 *
 * `fetch` addresses these problems. It runs all fetches in order, which removes race conditions
 * and forces the developer to handle errors.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodos$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('GET_TODOS'),
 *       fetch({
 *         // provides an action
 *         run: (a: GetTodos) => {
 *           return this.backend.getAll().pipe(
 *             map((response) => ({
 *               type: 'TODOS',
 *               todos: response.todos,
 *             }))
 *           );
 *         },
 *         onError: (action: GetTodos, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * This is correct, but because it set the concurrency to 1, it may not be performant.
 *
 * To fix that, you can provide the `id` function, like this:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       ofType('GET_TODO'),
 *       fetch({
 *         id: (todo: GetTodo) => {
 *           return todo.id;
 *         },
 *         // provides an action
 *         run: (todo: GetTodo) => {
 *           return this.backend.getTodo(todo.id).map((response) => ({
 *             type: 'LOAD_TODO_SUCCESS',
 *             todo: response.todo,
 *           }));
 *         },
 *         onError: (action: GetTodo, error: any) => {
 *           // dispatch an undo action to undo the changes in the client state
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
 *
 * In addition, if there are multiple requests for Todo 1 scheduled, it will only run the last one.
 *
 * @param opts
 */
export function fetch(opts) {
    return (source) => {
        if (opts.id) {
            const groupedFetches = source.pipe(mapActionAndState(), groupBy(([action, ...store]) => {
                return opts.id(action, ...store);
            }));
            return groupedFetches.pipe(mergeMap((pairs) => pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)))));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
/**
 * @whatItDoes Handles data fetching as part of router navigation.
 *
 * Data fetching implemented naively suffers from race conditions and poor error handling.
 *
 * `navigation` addresses these problems.
 *
 * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
 * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
 * the last request.
 *
 * ## Example:
 *
 * ```typescript
 * @Injectable()
 * class TodoEffects {
 *   loadTodo$ = createEffect(() =>
 *     this.actions$.pipe(
 *       // listens for the routerNavigation action from @ngrx/router-store
 *       navigation(TodoComponent, {
 *         run: (activatedRouteSnapshot: ActivatedRouteSnapshot) => {
 *           return this.backend
 *             .fetchTodo(activatedRouteSnapshot.params['id'])
 *             .pipe(
 *               map((todo) => ({
 *                 type: 'LOAD_TODO_SUCCESS',
 *                 todo: todo,
 *               }))
 *             );
 *         },
 *         onError: (
 *           activatedRouteSnapshot: ActivatedRouteSnapshot,
 *           error: any
 *         ) => {
 *           // we can log and error here and return null
 *           // we can also navigate back
 *           return null;
 *         },
 *       })
 *     )
 *   );
 *
 *   constructor(private actions$: Actions, private backend: Backend) {}
 * }
 * ```
 *
 * @param component
 * @param opts
 */
export function navigation(component, opts) {
    return (source) => {
        const nav = source.pipe(mapActionAndState(), filter(([action]) => isStateSnapshot(action)), map(([action, ...slices]) => {
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return [
                findSnapshot(component, action.payload.routerState.root),
                ...slices,
            ];
        }), filter(([snapshot]) => !!snapshot));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
function runWithErrorHandling(run, onError) {
    return ([action, ...slices]) => {
        try {
            const r = wrapIntoObservable(run(action, ...slices));
            return r.pipe(catchError((e) => wrapIntoObservable(onError(action, e))));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * @whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 */
function mapActionAndState() {
    return (source) => {
        return source.pipe(map((value) => normalizeActionAndState(value)));
    };
}
/**
 * @whatItDoes Normalizes either a bare action or an array of action and slices
 * into an array of action and slices (or undefined)
 */
function normalizeActionAndState(args) {
    let action, slices;
    if (args instanceof Array) {
        [action, ...slices] = args;
    }
    else {
        slices = [];
        action = args;
    }
    return [action, ...slices];
}
/**
 * @whatItDoes Provides convenience methods for implementing common operations of persisting data.
 *
 * @deprecated Use the individual operators instead. Will be removed in v15.
 */
export class DataPersistence {
    constructor(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    /**
     * See {@link pessimisticUpdate} operator for more information.
     *
     * @deprecated Use the {@link pessimisticUpdate} operator instead.
     * The {@link DataPersistence} class will be removed in v15.
     */
    pessimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), pessimisticUpdate(opts));
    }
    /**
     * See {@link optimisticUpdate} operator for more information.
     *
     * @deprecated Use the {@link optimisticUpdate} operator instead.
     * The {@link DataPersistence} class will be removed in v15.
     */
    optimisticUpdate(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), optimisticUpdate(opts));
    }
    /**
     * See {@link fetch} operator for more information.
     *
     * @deprecated Use the {@link fetch} operator instead.
     * The {@link DataPersistence} class will be removed in v15.
     */
    fetch(actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), fetch(opts));
    }
    /**
     * See {@link navigation} operator for more information.
     *
     * @deprecated Use the {@link navigation} operator instead.
     * The {@link DataPersistence} class will be removed in v15.
     */
    navigation(component, opts) {
        return this.actions.pipe(withLatestFrom(this.store), navigation(component, opts));
    }
}
DataPersistence.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.0", ngImport: i0, type: DataPersistence, deps: [{ token: i1.Store }, { token: i2.Actions }], target: i0.ɵɵFactoryTarget.Injectable });
DataPersistence.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.0", ngImport: i0, type: DataPersistence });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.0", ngImport: i0, type: DataPersistence, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Store }, { type: i2.Actions }]; } });
function findSnapshot(component, s) {
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    for (const c of s.children) {
        const ss = findSnapshot(component, c);
        if (ss) {
            return ss;
        }
    }
    return null;
}
function wrapIntoObservable(obj) {
    if (isObservable(obj)) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of(obj);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1wZXJzaXN0ZW5jZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9ydW50aW1lL254L2RhdGEtcGVyc2lzdGVuY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBUSxNQUFNLGVBQWUsQ0FBQztBQUVqRCxPQUFPLEVBQVcsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxpQkFBaUIsRUFBMEIsTUFBTSxvQkFBb0IsQ0FBQztBQUUvRSxPQUFPLEVBQUUsWUFBWSxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQ0wsVUFBVSxFQUNWLFNBQVMsRUFDVCxNQUFNLEVBQ04sT0FBTyxFQUNQLEdBQUcsRUFDSCxRQUFRLEVBQ1IsU0FBUyxFQUNULGNBQWMsR0FDZixNQUFNLGdCQUFnQixDQUFDOzs7O0FBcUN4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3REc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQy9CLElBQWlDO0lBRWpDLE9BQU8sQ0FBQyxNQUFnQyxFQUFzQixFQUFFO1FBQzlELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FDaEIsaUJBQWlCLEVBQUUsRUFDbkIsU0FBUyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQ3hELENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlERztBQUNILE1BQU0sVUFBVSxnQkFBZ0IsQ0FDOUIsSUFBZ0M7SUFFaEMsT0FBTyxDQUFDLE1BQWdDLEVBQXNCLEVBQUU7UUFDOUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixpQkFBaUIsRUFBRSxFQUNuQixTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FDM0QsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0E2RUc7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUNuQixJQUFxQjtJQUVyQixPQUFPLENBQUMsTUFBZ0MsRUFBc0IsRUFBRTtRQUM5RCxJQUFJLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDWCxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUNoQyxpQkFBaUIsRUFBRSxFQUNuQixPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxHQUFHLEtBQUssQ0FBQyxFQUFFLEVBQUU7Z0JBQzdCLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQztZQUNuQyxDQUFDLENBQUMsQ0FDSCxDQUFDO1lBRUYsT0FBTyxjQUFjLENBQUMsSUFBSSxDQUN4QixRQUFRLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUNqQixLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQ3BFLENBQ0YsQ0FBQztTQUNIO1FBRUQsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUNoQixpQkFBaUIsRUFBRSxFQUNuQixTQUFTLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FDeEQsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBZ0RHO0FBQ0gsTUFBTSxVQUFVLFVBQVUsQ0FDeEIsU0FBb0IsRUFDcEIsSUFBNkI7SUFFN0IsT0FBTyxDQUFDLE1BQWdDLEVBQUUsRUFBRTtRQUMxQyxNQUFNLEdBQUcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUNyQixpQkFBaUIsRUFBRSxFQUNuQixNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsRUFDN0MsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsRUFBRSxFQUFFO1lBQzFCLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLEVBQUU7Z0JBQzVCLG9EQUFvRDtnQkFDcEQsMENBQTBDO2dCQUMxQyxPQUFPO2FBQ1I7WUFFRCxPQUFPO2dCQUNMLFlBQVksQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO2dCQUN4RCxHQUFHLE1BQU07YUFDd0IsQ0FBQztRQUN0QyxDQUFDLENBQUMsRUFDRixNQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQ25DLENBQUM7UUFFRixPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRSxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQsU0FBUyxlQUFlLENBQ3RCLE1BQVc7SUFFWCxPQUFPLE1BQU0sQ0FBQyxJQUFJLEtBQUssaUJBQWlCLENBQUM7QUFDM0MsQ0FBQztBQUVELFNBQVMsb0JBQW9CLENBQzNCLEdBQTBELEVBQzFELE9BQVk7SUFFWixPQUFPLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQVksRUFBaUIsRUFBRTtRQUN2RCxJQUFJO1lBQ0YsTUFBTSxDQUFDLEdBQUcsa0JBQWtCLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDckQsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUMxRTtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDL0M7SUFDSCxDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUyxpQkFBaUI7SUFDeEIsT0FBTyxDQUFDLE1BQWtELEVBQUUsRUFBRTtRQUM1RCxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQ2hCLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsdUJBQXVCLENBQUMsS0FBSyxDQUFjLENBQUMsQ0FDNUQsQ0FBQztJQUNKLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLHVCQUF1QixDQUM5QixJQUFvQztJQUVwQyxJQUFJLE1BQVMsRUFBRSxNQUFTLENBQUM7SUFFekIsSUFBSSxJQUFJLFlBQVksS0FBSyxFQUFFO1FBQ3pCLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDO0tBQzVCO1NBQU07UUFDTCxNQUFNLEdBQUcsRUFBTyxDQUFDO1FBQ2pCLE1BQU0sR0FBRyxJQUFJLENBQUM7S0FDZjtJQUVELE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUM3QixDQUFDO0FBRUQ7Ozs7R0FJRztBQUVILE1BQU0sT0FBTyxlQUFlO0lBQzFCLFlBQW1CLEtBQWUsRUFBUyxPQUFnQjtRQUF4QyxVQUFLLEdBQUwsS0FBSyxDQUFVO1FBQVMsWUFBTyxHQUFQLE9BQU8sQ0FBUztJQUFHLENBQUM7SUFFL0Q7Ozs7O09BS0c7SUFDSCxpQkFBaUIsQ0FDZixVQUFrQyxFQUNsQyxJQUFtQztRQUVuQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUN0QixNQUFNLENBQUksVUFBVSxDQUFDLEVBQ3JCLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQzFCLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUN4QixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsZ0JBQWdCLENBQ2QsVUFBa0MsRUFDbEMsSUFBa0M7UUFFbEMsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FDdEIsTUFBTSxDQUFJLFVBQVUsQ0FBQyxFQUNyQixjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUMxQixnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FDdkIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILEtBQUssQ0FDSCxVQUFrQyxFQUNsQyxJQUF1QjtRQUV2QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUN0QixNQUFNLENBQUksVUFBVSxDQUFDLEVBQ3JCLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQzFCLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FDWixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsVUFBVSxDQUNSLFNBQW9CLEVBQ3BCLElBQStCO1FBRS9CLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQ3RCLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQzFCLFVBQVUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQzVCLENBQUM7SUFDSixDQUFDOzs0R0FwRVUsZUFBZTtnSEFBZixlQUFlOzJGQUFmLGVBQWU7a0JBRDNCLFVBQVU7O0FBd0VYLFNBQVMsWUFBWSxDQUNuQixTQUFvQixFQUNwQixDQUF5QjtJQUV6QixJQUFJLENBQUMsQ0FBQyxXQUFXLElBQUksQ0FBQyxDQUFDLFdBQVcsQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFO1FBQzFELE9BQU8sQ0FBQyxDQUFDO0tBQ1Y7SUFDRCxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUU7UUFDMUIsTUFBTSxFQUFFLEdBQUcsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFJLEVBQUUsRUFBRTtZQUNOLE9BQU8sRUFBRSxDQUFDO1NBQ1g7S0FDRjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQUksR0FBNkI7SUFDMUQsSUFBSSxZQUFZLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDckIsT0FBTyxHQUFHLENBQUM7S0FDWjtTQUFNLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDZixPQUFPLEVBQUUsRUFBRSxDQUFDO0tBQ2I7U0FBTTtRQUNMLE9BQU8sRUFBRSxDQUFDLEdBQVEsQ0FBQyxDQUFDO0tBQ3JCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlU25hcHNob3QsIFJvdXRlclN0YXRlU25hcHNob3QgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQWN0aW9ucywgb2ZUeXBlIH0gZnJvbSAnQG5ncngvZWZmZWN0cyc7XG5pbXBvcnQgeyBST1VURVJfTkFWSUdBVElPTiwgUm91dGVyTmF2aWdhdGlvbkFjdGlvbiB9IGZyb20gJ0BuZ3J4L3JvdXRlci1zdG9yZSc7XG5pbXBvcnQgeyBBY3Rpb24sIFN0b3JlLCBBY3Rpb25DcmVhdG9yIH0gZnJvbSAnQG5ncngvc3RvcmUnO1xuaW1wb3J0IHsgaXNPYnNlcnZhYmxlLCBPYnNlcnZhYmxlLCBvZiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgY2F0Y2hFcnJvcixcbiAgY29uY2F0TWFwLFxuICBmaWx0ZXIsXG4gIGdyb3VwQnksXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHN3aXRjaE1hcCxcbiAgd2l0aExhdGVzdEZyb20sXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBQZXNzaW1pc3RpY1VwZGF0ZU9wdHM8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBPiB7XG4gIHJ1bihhOiBBLCAuLi5zbGljZXM6IFsuLi5UXSk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbiB8IHZvaWQ7XG4gIG9uRXJyb3IoYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGltaXN0aWNVcGRhdGVPcHRzPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQT4ge1xuICBydW4oYTogQSwgLi4uc2xpY2VzOiBbLi4uVF0pOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICB1bmRvQWN0aW9uKGE6IEEsIGU6IGFueSk6IE9ic2VydmFibGU8QWN0aW9uPiB8IEFjdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGZXRjaE9wdHM8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBPiB7XG4gIGlkPyhhOiBBLCAuLi5zbGljZXM6IFsuLi5UXSk6IGFueTtcbiAgcnVuKGE6IEEsIC4uLnNsaWNlczogWy4uLlRdKTogT2JzZXJ2YWJsZTxBY3Rpb24+IHwgQWN0aW9uIHwgdm9pZDtcbiAgb25FcnJvcj8oYTogQSwgZTogYW55KTogT2JzZXJ2YWJsZTxhbnk+IHwgYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhbmRsZU5hdmlnYXRpb25PcHRzPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPj4ge1xuICBydW4oXG4gICAgYTogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcbiAgICAuLi5zbGljZXM6IFsuLi5UXVxuICApOiBPYnNlcnZhYmxlPEFjdGlvbj4gfCBBY3Rpb24gfCB2b2lkO1xuICBvbkVycm9yPyhhOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBlOiBhbnkpOiBPYnNlcnZhYmxlPGFueT4gfCBhbnk7XG59XG5cbmV4cG9ydCB0eXBlIEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlczxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEE+ID1cbiAgfCBBXG4gIHwgW0EsIC4uLlRdO1xuZXhwb3J0IHR5cGUgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGU8VCwgQT4gPSBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZXM8W1RdLCBBPjtcbmV4cG9ydCB0eXBlIEFjdGlvblN0YXRlc1N0cmVhbTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEE+ID0gT2JzZXJ2YWJsZTxcbiAgQWN0aW9uT3JBY3Rpb25XaXRoU3RhdGVzPFQsIEE+XG4+O1xuZXhwb3J0IHR5cGUgQWN0aW9uU3RhdGVTdHJlYW08VCwgQT4gPSBPYnNlcnZhYmxlPFxuICBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZXM8W1RdLCBBPlxuPjtcblxuLyoqXG4gKlxuICogQHdoYXRJdERvZXMgSGFuZGxlcyBwZXNzaW1pc3RpYyB1cGRhdGVzICh1cGRhdGluZyB0aGUgc2VydmVyIGZpcnN0KS5cbiAqXG4gKiBVcGRhdGluZyB0aGUgc2VydmVyLCB3aGVuIGltcGxlbWVudGVkIG5haXZlbHksIHN1ZmZlcnMgZnJvbSByYWNlIGNvbmRpdGlvbnMgYW5kIHBvb3IgZXJyb3IgaGFuZGxpbmcuXG4gKlxuICogYHBlc3NpbWlzdGljVXBkYXRlYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMuIEl0IHJ1bnMgYWxsIGZldGNoZXMgaW4gb3JkZXIsIHdoaWNoIHJlbW92ZXMgcmFjZSBjb25kaXRpb25zXG4gKiBhbmQgZm9yY2VzIHRoZSBkZXZlbG9wZXIgdG8gaGFuZGxlIGVycm9ycy5cbiAqXG4gKiAjIyBFeGFtcGxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIEBJbmplY3RhYmxlKClcbiAqIGNsYXNzIFRvZG9FZmZlY3RzIHtcbiAqICAgdXBkYXRlVG9kbyQgPSBjcmVhdGVFZmZlY3QoKCkgPT5cbiAqICAgICB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gKiAgICAgICBvZlR5cGUoJ1VQREFURV9UT0RPJyksXG4gKiAgICAgICBwZXNzaW1pc3RpY1VwZGF0ZSh7XG4gKiAgICAgICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvblxuICogICAgICAgICBydW46IChhY3Rpb246IFVwZGF0ZVRvZG8pID0+IHtcbiAqICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGJhY2tlbmQgZmlyc3QsIGFuZCB0aGVuIGRpc3BhdGNoIGFuIGFjdGlvbiB0aGF0IHdpbGxcbiAqICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGNsaWVudCBzaWRlXG4gKiAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC51cGRhdGVUb2RvKGFjdGlvbi50b2RvLmlkLCBhY3Rpb24udG9kbykucGlwZShcbiAqICAgICAgICAgICAgIG1hcCgodXBkYXRlZCkgPT4gKHtcbiAqICAgICAgICAgICAgICAgdHlwZTogJ1VQREFURV9UT0RPX1NVQ0NFU1MnLFxuICogICAgICAgICAgICAgICB0b2RvOiB1cGRhdGVkLFxuICogICAgICAgICAgICAgfSkpXG4gKiAgICAgICAgICAgKTtcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgb25FcnJvcjogKGFjdGlvbjogVXBkYXRlVG9kbywgZXJyb3I6IGFueSkgPT4ge1xuICogICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gdW5kbyB0aGUgY2hhbmdlcyBvbiB0aGUgY2xpZW50IHNpZGUuXG4gKiAgICAgICAgICAgLy8gd2UgY2FuIGRpc3BhdGNoIGFuIGVycm9yLCBvciBzaW1wbHkgbG9nIHRoZSBlcnJvciBoZXJlIGFuZCByZXR1cm4gYG51bGxgXG4gKiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICB9KVxuICogICAgIClcbiAqICAgKTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWN0aW9ucyQ6IEFjdGlvbnMsIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCBpZiB5b3UgZG9uJ3QgcmV0dXJuIGEgbmV3IGFjdGlvbiBmcm9tIHRoZSBydW4gY2FsbGJhY2ssIHlvdSBtdXN0IHNldCB0aGUgZGlzcGF0Y2ggcHJvcGVydHlcbiAqIG9mIHRoZSBlZmZlY3QgdG8gZmFsc2UsIGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gKiAgIHVwZGF0ZVRvZG8kID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gKiAgICAgdGhpcy5hY3Rpb25zJC5waXBlKFxuICogICAgICAgLy8uLi5cbiAqICAgICApLCB7IGRpc3BhdGNoOiBmYWxzZSB9XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gcGVzc2ltaXN0aWNVcGRhdGU8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgb3B0czogUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFQsIEE+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlc1N0cmVhbTxULCBBPik6IE9ic2VydmFibGU8QWN0aW9uPiA9PiB7XG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSlcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqXG4gKiBAd2hhdEl0RG9lcyBIYW5kbGVzIG9wdGltaXN0aWMgdXBkYXRlcyAodXBkYXRpbmcgdGhlIGNsaWVudCBmaXJzdCkuXG4gKlxuICogSXQgcnVucyBhbGwgZmV0Y2hlcyBpbiBvcmRlciwgd2hpY2ggcmVtb3ZlcyByYWNlIGNvbmRpdGlvbnMgYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gKlxuICogV2hlbiB1c2luZyBgb3B0aW1pc3RpY1VwZGF0ZWAsIGluIGNhc2Ugb2YgYSBmYWlsdXJlLCB0aGUgZGV2ZWxvcGVyIGhhcyBhbHJlYWR5IHVwZGF0ZWQgdGhlIHN0YXRlIGxvY2FsbHksXG4gKiBzbyB0aGUgZGV2ZWxvcGVyIG11c3QgcHJvdmlkZSBhbiB1bmRvIGFjdGlvbi5cbiAqXG4gKiBUaGUgZXJyb3IgaGFuZGxpbmcgbXVzdCBiZSBkb25lIGluIHRoZSBjYWxsYmFjaywgb3IgYnkgbWVhbnMgb2YgdGhlIHVuZG8gYWN0aW9uLlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICogICB1cGRhdGVUb2RvJCA9IGNyZWF0ZUVmZmVjdCgoKSA9PlxuICogICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICAgICAgIG9mVHlwZSgnVVBEQVRFX1RPRE8nKSxcbiAqICAgICAgIG9wdGltaXN0aWNVcGRhdGUoe1xuICogICAgICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb25cbiAqICAgICAgICAgcnVuOiAoYWN0aW9uOiBVcGRhdGVUb2RvKSA9PiB7XG4gKiAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC51cGRhdGVUb2RvKGFjdGlvbi50b2RvLmlkLCBhY3Rpb24udG9kbykucGlwZShcbiAqICAgICAgICAgICAgIG1hcFRvKHtcbiAqICAgICAgICAgICAgICAgdHlwZTogJ1VQREFURV9UT0RPX1NVQ0NFU1MnLFxuICogICAgICAgICAgICAgfSlcbiAqICAgICAgICAgICApO1xuICogICAgICAgICB9LFxuICogICAgICAgICB1bmRvQWN0aW9uOiAoYWN0aW9uOiBVcGRhdGVUb2RvLCBlcnJvcjogYW55KSA9PiB7XG4gKiAgICAgICAgICAgLy8gZGlzcGF0Y2ggYW4gdW5kbyBhY3Rpb24gdG8gdW5kbyB0aGUgY2hhbmdlcyBpbiB0aGUgY2xpZW50IHN0YXRlXG4gKiAgICAgICAgICAgcmV0dXJuIHtcbiAqICAgICAgICAgICAgIHR5cGU6ICdVTkRPX1RPRE9fVVBEQVRFJyxcbiAqICAgICAgICAgICAgIHRvZG86IGFjdGlvbi50b2RvLFxuICogICAgICAgICAgIH07XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICB9KVxuICogICAgIClcbiAqICAgKTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWN0aW9ucyQ6IEFjdGlvbnMsIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCBpZiB5b3UgZG9uJ3QgcmV0dXJuIGEgbmV3IGFjdGlvbiBmcm9tIHRoZSBydW4gY2FsbGJhY2ssIHlvdSBtdXN0IHNldCB0aGUgZGlzcGF0Y2ggcHJvcGVydHlcbiAqIG9mIHRoZSBlZmZlY3QgdG8gZmFsc2UsIGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gKiAgIHVwZGF0ZVRvZG8kID0gY3JlYXRlRWZmZWN0KCgpID0+XG4gKiAgICAgdGhpcy5hY3Rpb25zJC5waXBlKFxuICogICAgICAgLy8uLi5cbiAqICAgICApLCB7IGRpc3BhdGNoOiBmYWxzZSB9XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gb3B0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW1pc3RpY1VwZGF0ZTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEEgZXh0ZW5kcyBBY3Rpb24+KFxuICBvcHRzOiBPcHRpbWlzdGljVXBkYXRlT3B0czxULCBBPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZXNTdHJlYW08VCwgQT4pOiBPYnNlcnZhYmxlPEFjdGlvbj4gPT4ge1xuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBjb25jYXRNYXAocnVuV2l0aEVycm9ySGFuZGxpbmcob3B0cy5ydW4sIG9wdHMudW5kb0FjdGlvbikpXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKlxuICogQHdoYXRJdERvZXMgSGFuZGxlcyBkYXRhIGZldGNoaW5nLlxuICpcbiAqIERhdGEgZmV0Y2hpbmcgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIGBmZXRjaGAgYWRkcmVzc2VzIHRoZXNlIHByb2JsZW1zLiBJdCBydW5zIGFsbCBmZXRjaGVzIGluIG9yZGVyLCB3aGljaCByZW1vdmVzIHJhY2UgY29uZGl0aW9uc1xuICogYW5kIGZvcmNlcyB0aGUgZGV2ZWxvcGVyIHRvIGhhbmRsZSBlcnJvcnMuXG4gKlxuICogIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gKiAgIGxvYWRUb2RvcyQgPSBjcmVhdGVFZmZlY3QoKCkgPT5cbiAqICAgICB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gKiAgICAgICBvZlR5cGUoJ0dFVF9UT0RPUycpLFxuICogICAgICAgZmV0Y2goe1xuICogICAgICAgICAvLyBwcm92aWRlcyBhbiBhY3Rpb25cbiAqICAgICAgICAgcnVuOiAoYTogR2V0VG9kb3MpID0+IHtcbiAqICAgICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmdldEFsbCgpLnBpcGUoXG4gKiAgICAgICAgICAgICBtYXAoKHJlc3BvbnNlKSA9PiAoe1xuICogICAgICAgICAgICAgICB0eXBlOiAnVE9ET1MnLFxuICogICAgICAgICAgICAgICB0b2RvczogcmVzcG9uc2UudG9kb3MsXG4gKiAgICAgICAgICAgICB9KSlcbiAqICAgICAgICAgICApO1xuICogICAgICAgICB9LFxuICogICAgICAgICBvbkVycm9yOiAoYWN0aW9uOiBHZXRUb2RvcywgZXJyb3I6IGFueSkgPT4ge1xuICogICAgICAgICAgIC8vIGRpc3BhdGNoIGFuIHVuZG8gYWN0aW9uIHRvIHVuZG8gdGhlIGNoYW5nZXMgaW4gdGhlIGNsaWVudCBzdGF0ZVxuICogICAgICAgICAgIHJldHVybiBudWxsO1xuICogICAgICAgICB9LFxuICogICAgICAgfSlcbiAqICAgICApXG4gKiAgICk7XG4gKlxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFjdGlvbnMkOiBBY3Rpb25zLCBwcml2YXRlIGJhY2tlbmQ6IEJhY2tlbmQpIHt9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGlzIGNvcnJlY3QsIGJ1dCBiZWNhdXNlIGl0IHNldCB0aGUgY29uY3VycmVuY3kgdG8gMSwgaXQgbWF5IG5vdCBiZSBwZXJmb3JtYW50LlxuICpcbiAqIFRvIGZpeCB0aGF0LCB5b3UgY2FuIHByb3ZpZGUgdGhlIGBpZGAgZnVuY3Rpb24sIGxpa2UgdGhpczpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBASW5qZWN0YWJsZSgpXG4gKiBjbGFzcyBUb2RvRWZmZWN0cyB7XG4gKiAgIGxvYWRUb2RvJCA9IGNyZWF0ZUVmZmVjdCgoKSA9PlxuICogICAgIHRoaXMuYWN0aW9ucyQucGlwZShcbiAqICAgICAgIG9mVHlwZSgnR0VUX1RPRE8nKSxcbiAqICAgICAgIGZldGNoKHtcbiAqICAgICAgICAgaWQ6ICh0b2RvOiBHZXRUb2RvKSA9PiB7XG4gKiAgICAgICAgICAgcmV0dXJuIHRvZG8uaWQ7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIC8vIHByb3ZpZGVzIGFuIGFjdGlvblxuICogICAgICAgICBydW46ICh0b2RvOiBHZXRUb2RvKSA9PiB7XG4gKiAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5nZXRUb2RvKHRvZG8uaWQpLm1hcCgocmVzcG9uc2UpID0+ICh7XG4gKiAgICAgICAgICAgICB0eXBlOiAnTE9BRF9UT0RPX1NVQ0NFU1MnLFxuICogICAgICAgICAgICAgdG9kbzogcmVzcG9uc2UudG9kbyxcbiAqICAgICAgICAgICB9KSk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIG9uRXJyb3I6IChhY3Rpb246IEdldFRvZG8sIGVycm9yOiBhbnkpID0+IHtcbiAqICAgICAgICAgICAvLyBkaXNwYXRjaCBhbiB1bmRvIGFjdGlvbiB0byB1bmRvIHRoZSBjaGFuZ2VzIGluIHRoZSBjbGllbnQgc3RhdGVcbiAqICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAqICAgICAgICAgfSxcbiAqICAgICAgIH0pXG4gKiAgICAgKVxuICogICApO1xuICpcbiAqICAgY29uc3RydWN0b3IocHJpdmF0ZSBhY3Rpb25zJDogQWN0aW9ucywgcHJpdmF0ZSBiYWNrZW5kOiBCYWNrZW5kKSB7fVxuICogfVxuICogYGBgXG4gKlxuICogV2l0aCB0aGlzIHNldHVwLCB0aGUgcmVxdWVzdHMgZm9yIFRvZG8gMSB3aWxsIHJ1biBjb25jdXJyZW50bHkgd2l0aCB0aGUgcmVxdWVzdHMgZm9yIFRvZG8gMi5cbiAqXG4gKiBJbiBhZGRpdGlvbiwgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHJlcXVlc3RzIGZvciBUb2RvIDEgc2NoZWR1bGVkLCBpdCB3aWxsIG9ubHkgcnVuIHRoZSBsYXN0IG9uZS5cbiAqXG4gKiBAcGFyYW0gb3B0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gZmV0Y2g8VCBleHRlbmRzIEFycmF5PHVua25vd24+LCBBIGV4dGVuZHMgQWN0aW9uPihcbiAgb3B0czogRmV0Y2hPcHRzPFQsIEE+XG4pIHtcbiAgcmV0dXJuIChzb3VyY2U6IEFjdGlvblN0YXRlc1N0cmVhbTxULCBBPik6IE9ic2VydmFibGU8QWN0aW9uPiA9PiB7XG4gICAgaWYgKG9wdHMuaWQpIHtcbiAgICAgIGNvbnN0IGdyb3VwZWRGZXRjaGVzID0gc291cmNlLnBpcGUoXG4gICAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICAgIGdyb3VwQnkoKFthY3Rpb24sIC4uLnN0b3JlXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBvcHRzLmlkKGFjdGlvbiwgLi4uc3RvcmUpO1xuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIGdyb3VwZWRGZXRjaGVzLnBpcGUoXG4gICAgICAgIG1lcmdlTWFwKChwYWlycykgPT5cbiAgICAgICAgICBwYWlycy5waXBlKHN3aXRjaE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSkpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvdXJjZS5waXBlKFxuICAgICAgbWFwQWN0aW9uQW5kU3RhdGUoKSxcbiAgICAgIGNvbmNhdE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSlcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEB3aGF0SXREb2VzIEhhbmRsZXMgZGF0YSBmZXRjaGluZyBhcyBwYXJ0IG9mIHJvdXRlciBuYXZpZ2F0aW9uLlxuICpcbiAqIERhdGEgZmV0Y2hpbmcgaW1wbGVtZW50ZWQgbmFpdmVseSBzdWZmZXJzIGZyb20gcmFjZSBjb25kaXRpb25zIGFuZCBwb29yIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIGBuYXZpZ2F0aW9uYCBhZGRyZXNzZXMgdGhlc2UgcHJvYmxlbXMuXG4gKlxuICogSXQgY2hlY2tzIGlmIGFuIGFjdGl2YXRlZCByb3V0ZXIgc3RhdGUgY29udGFpbnMgdGhlIHBhc3NlZCBpbiBjb21wb25lbnQgdHlwZSwgYW5kLCBpZiBpdCBkb2VzLCBydW5zIHRoZSBgcnVuYFxuICogY2FsbGJhY2suIEl0IHByb3ZpZGVzIHRoZSBhY3RpdmF0ZWQgc25hcHNob3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb21wb25lbnQgYW5kIHRoZSBjdXJyZW50IHN0YXRlLiBBbmQgaXQgb25seSBydW5zXG4gKiB0aGUgbGFzdCByZXF1ZXN0LlxuICpcbiAqICMjIEV4YW1wbGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogQEluamVjdGFibGUoKVxuICogY2xhc3MgVG9kb0VmZmVjdHMge1xuICogICBsb2FkVG9kbyQgPSBjcmVhdGVFZmZlY3QoKCkgPT5cbiAqICAgICB0aGlzLmFjdGlvbnMkLnBpcGUoXG4gKiAgICAgICAvLyBsaXN0ZW5zIGZvciB0aGUgcm91dGVyTmF2aWdhdGlvbiBhY3Rpb24gZnJvbSBAbmdyeC9yb3V0ZXItc3RvcmVcbiAqICAgICAgIG5hdmlnYXRpb24oVG9kb0NvbXBvbmVudCwge1xuICogICAgICAgICBydW46IChhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90KSA9PiB7XG4gKiAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZFxuICogICAgICAgICAgICAgLmZldGNoVG9kbyhhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnBhcmFtc1snaWQnXSlcbiAqICAgICAgICAgICAgIC5waXBlKFxuICogICAgICAgICAgICAgICBtYXAoKHRvZG8pID0+ICh7XG4gKiAgICAgICAgICAgICAgICAgdHlwZTogJ0xPQURfVE9ET19TVUNDRVNTJyxcbiAqICAgICAgICAgICAgICAgICB0b2RvOiB0b2RvLFxuICogICAgICAgICAgICAgICB9KSlcbiAqICAgICAgICAgICAgICk7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICAgIG9uRXJyb3I6IChcbiAqICAgICAgICAgICBhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LFxuICogICAgICAgICAgIGVycm9yOiBhbnlcbiAqICAgICAgICAgKSA9PiB7XG4gKiAgICAgICAgICAgLy8gd2UgY2FuIGxvZyBhbmQgZXJyb3IgaGVyZSBhbmQgcmV0dXJuIG51bGxcbiAqICAgICAgICAgICAvLyB3ZSBjYW4gYWxzbyBuYXZpZ2F0ZSBiYWNrXG4gKiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gKiAgICAgICAgIH0sXG4gKiAgICAgICB9KVxuICogICAgIClcbiAqICAgKTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWN0aW9ucyQ6IEFjdGlvbnMsIHByaXZhdGUgYmFja2VuZDogQmFja2VuZCkge31cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjb21wb25lbnRcbiAqIEBwYXJhbSBvcHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYXZpZ2F0aW9uPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQSBleHRlbmRzIEFjdGlvbj4oXG4gIGNvbXBvbmVudDogVHlwZTxhbnk+LFxuICBvcHRzOiBIYW5kbGVOYXZpZ2F0aW9uT3B0czxUPlxuKSB7XG4gIHJldHVybiAoc291cmNlOiBBY3Rpb25TdGF0ZXNTdHJlYW08VCwgQT4pID0+IHtcbiAgICBjb25zdCBuYXYgPSBzb3VyY2UucGlwZShcbiAgICAgIG1hcEFjdGlvbkFuZFN0YXRlKCksXG4gICAgICBmaWx0ZXIoKFthY3Rpb25dKSA9PiBpc1N0YXRlU25hcHNob3QoYWN0aW9uKSksXG4gICAgICBtYXAoKFthY3Rpb24sIC4uLnNsaWNlc10pID0+IHtcbiAgICAgICAgaWYgKCFpc1N0YXRlU25hcHNob3QoYWN0aW9uKSkge1xuICAgICAgICAgIC8vIEJlY2F1c2Ugb2YgdGhlIGFib3ZlIGZpbHRlciB3ZSdsbCBuZXZlciBnZXQgaGVyZSxcbiAgICAgICAgICAvLyBidXQgdGhpcyBwcm9wZXJseSB0eXBlIG5hcnJvd3MgYGFjdGlvbmBcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGZpbmRTbmFwc2hvdChjb21wb25lbnQsIGFjdGlvbi5wYXlsb2FkLnJvdXRlclN0YXRlLnJvb3QpLFxuICAgICAgICAgIC4uLnNsaWNlcyxcbiAgICAgICAgXSBhcyBbQWN0aXZhdGVkUm91dGVTbmFwc2hvdCwgLi4uVF07XG4gICAgICB9KSxcbiAgICAgIGZpbHRlcigoW3NuYXBzaG90XSkgPT4gISFzbmFwc2hvdClcbiAgICApO1xuXG4gICAgcmV0dXJuIG5hdi5waXBlKHN3aXRjaE1hcChydW5XaXRoRXJyb3JIYW5kbGluZyhvcHRzLnJ1biwgb3B0cy5vbkVycm9yKSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlU25hcHNob3QoXG4gIGFjdGlvbjogYW55XG4pOiBhY3Rpb24gaXMgUm91dGVyTmF2aWdhdGlvbkFjdGlvbjxSb3V0ZXJTdGF0ZVNuYXBzaG90PiB7XG4gIHJldHVybiBhY3Rpb24udHlwZSA9PT0gUk9VVEVSX05BVklHQVRJT047XG59XG5cbmZ1bmN0aW9uIHJ1bldpdGhFcnJvckhhbmRsaW5nPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQSwgUj4oXG4gIHJ1bjogKGE6IEEsIC4uLnNsaWNlczogWy4uLlRdKSA9PiBPYnNlcnZhYmxlPFI+IHwgUiB8IHZvaWQsXG4gIG9uRXJyb3I6IGFueVxuKSB7XG4gIHJldHVybiAoW2FjdGlvbiwgLi4uc2xpY2VzXTogW0EsIC4uLlRdKTogT2JzZXJ2YWJsZTxSPiA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHIgPSB3cmFwSW50b09ic2VydmFibGUocnVuKGFjdGlvbiwgLi4uc2xpY2VzKSk7XG4gICAgICByZXR1cm4gci5waXBlKGNhdGNoRXJyb3IoKGUpID0+IHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHdyYXBJbnRvT2JzZXJ2YWJsZShvbkVycm9yKGFjdGlvbiwgZSkpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBAd2hhdEl0RG9lcyBtYXBzIE9ic2VydmFibGU8QWN0aW9uIHwgW0FjdGlvbiwgU3RhdGVdPiB0b1xuICogT2JzZXJ2YWJsZTxbQWN0aW9uLCBTdGF0ZV0+XG4gKi9cbmZ1bmN0aW9uIG1hcEFjdGlvbkFuZFN0YXRlPFQgZXh0ZW5kcyBBcnJheTx1bmtub3duPiwgQT4oKSB7XG4gIHJldHVybiAoc291cmNlOiBPYnNlcnZhYmxlPEFjdGlvbk9yQWN0aW9uV2l0aFN0YXRlczxULCBBPj4pID0+IHtcbiAgICByZXR1cm4gc291cmNlLnBpcGUoXG4gICAgICBtYXAoKHZhbHVlKSA9PiBub3JtYWxpemVBY3Rpb25BbmRTdGF0ZSh2YWx1ZSkgYXMgW0EsIC4uLlRdKVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgTm9ybWFsaXplcyBlaXRoZXIgYSBiYXJlIGFjdGlvbiBvciBhbiBhcnJheSBvZiBhY3Rpb24gYW5kIHNsaWNlc1xuICogaW50byBhbiBhcnJheSBvZiBhY3Rpb24gYW5kIHNsaWNlcyAob3IgdW5kZWZpbmVkKVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBY3Rpb25BbmRTdGF0ZTxUIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIEE+KFxuICBhcmdzOiBBY3Rpb25PckFjdGlvbldpdGhTdGF0ZXM8VCwgQT5cbik6IFtBLCAuLi5UXSB7XG4gIGxldCBhY3Rpb246IEEsIHNsaWNlczogVDtcblxuICBpZiAoYXJncyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgW2FjdGlvbiwgLi4uc2xpY2VzXSA9IGFyZ3M7XG4gIH0gZWxzZSB7XG4gICAgc2xpY2VzID0gW10gYXMgVDtcbiAgICBhY3Rpb24gPSBhcmdzO1xuICB9XG5cbiAgcmV0dXJuIFthY3Rpb24sIC4uLnNsaWNlc107XG59XG5cbi8qKlxuICogQHdoYXRJdERvZXMgUHJvdmlkZXMgY29udmVuaWVuY2UgbWV0aG9kcyBmb3IgaW1wbGVtZW50aW5nIGNvbW1vbiBvcGVyYXRpb25zIG9mIHBlcnNpc3RpbmcgZGF0YS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgdGhlIGluZGl2aWR1YWwgb3BlcmF0b3JzIGluc3RlYWQuIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MTUuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhUGVyc2lzdGVuY2U8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3RvcmU6IFN0b3JlPFQ+LCBwdWJsaWMgYWN0aW9uczogQWN0aW9ucykge31cblxuICAvKipcbiAgICogU2VlIHtAbGluayBwZXNzaW1pc3RpY1VwZGF0ZX0gb3BlcmF0b3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUge0BsaW5rIHBlc3NpbWlzdGljVXBkYXRlfSBvcGVyYXRvciBpbnN0ZWFkLlxuICAgKiBUaGUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZX0gY2xhc3Mgd2lsbCBiZSByZW1vdmVkIGluIHYxNS5cbiAgICovXG4gIHBlc3NpbWlzdGljVXBkYXRlPEEgZXh0ZW5kcyBBY3Rpb24gPSBBY3Rpb24+KFxuICAgIGFjdGlvblR5cGU6IHN0cmluZyB8IEFjdGlvbkNyZWF0b3IsXG4gICAgb3B0czogUGVzc2ltaXN0aWNVcGRhdGVPcHRzPFtUXSwgQT5cbiAgKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hY3Rpb25zLnBpcGUoXG4gICAgICBvZlR5cGU8QT4oYWN0aW9uVHlwZSksXG4gICAgICB3aXRoTGF0ZXN0RnJvbSh0aGlzLnN0b3JlKSxcbiAgICAgIHBlc3NpbWlzdGljVXBkYXRlKG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIG9wdGltaXN0aWNVcGRhdGV9IG9wZXJhdG9yIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHtAbGluayBvcHRpbWlzdGljVXBkYXRlfSBvcGVyYXRvciBpbnN0ZWFkLlxuICAgKiBUaGUge0BsaW5rIERhdGFQZXJzaXN0ZW5jZX0gY2xhc3Mgd2lsbCBiZSByZW1vdmVkIGluIHYxNS5cbiAgICovXG4gIG9wdGltaXN0aWNVcGRhdGU8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nIHwgQWN0aW9uQ3JlYXRvcixcbiAgICBvcHRzOiBPcHRpbWlzdGljVXBkYXRlT3B0czxbVF0sIEE+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgb2ZUeXBlPEE+KGFjdGlvblR5cGUpLFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBvcHRpbWlzdGljVXBkYXRlKG9wdHMpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUge0BsaW5rIGZldGNofSBvcGVyYXRvciBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB7QGxpbmsgZmV0Y2h9IG9wZXJhdG9yIGluc3RlYWQuXG4gICAqIFRoZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlfSBjbGFzcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjE1LlxuICAgKi9cbiAgZmV0Y2g8QSBleHRlbmRzIEFjdGlvbiA9IEFjdGlvbj4oXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nIHwgQWN0aW9uQ3JlYXRvcixcbiAgICBvcHRzOiBGZXRjaE9wdHM8W1RdLCBBPlxuICApOiBPYnNlcnZhYmxlPGFueT4ge1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnMucGlwZShcbiAgICAgIG9mVHlwZTxBPihhY3Rpb25UeXBlKSxcbiAgICAgIHdpdGhMYXRlc3RGcm9tKHRoaXMuc3RvcmUpLFxuICAgICAgZmV0Y2gob3B0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSB7QGxpbmsgbmF2aWdhdGlvbn0gb3BlcmF0b3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUge0BsaW5rIG5hdmlnYXRpb259IG9wZXJhdG9yIGluc3RlYWQuXG4gICAqIFRoZSB7QGxpbmsgRGF0YVBlcnNpc3RlbmNlfSBjbGFzcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjE1LlxuICAgKi9cbiAgbmF2aWdhdGlvbihcbiAgICBjb21wb25lbnQ6IFR5cGU8YW55PixcbiAgICBvcHRzOiBIYW5kbGVOYXZpZ2F0aW9uT3B0czxbVF0+XG4gICk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aW9ucy5waXBlKFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5zdG9yZSksXG4gICAgICBuYXZpZ2F0aW9uKGNvbXBvbmVudCwgb3B0cylcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRTbmFwc2hvdChcbiAgY29tcG9uZW50OiBUeXBlPGFueT4sXG4gIHM6IEFjdGl2YXRlZFJvdXRlU25hcHNob3Rcbik6IEFjdGl2YXRlZFJvdXRlU25hcHNob3Qge1xuICBpZiAocy5yb3V0ZUNvbmZpZyAmJiBzLnJvdXRlQ29uZmlnLmNvbXBvbmVudCA9PT0gY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZm9yIChjb25zdCBjIG9mIHMuY2hpbGRyZW4pIHtcbiAgICBjb25zdCBzcyA9IGZpbmRTbmFwc2hvdChjb21wb25lbnQsIGMpO1xuICAgIGlmIChzcykge1xuICAgICAgcmV0dXJuIHNzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gd3JhcEludG9PYnNlcnZhYmxlPE8+KG9iajogT2JzZXJ2YWJsZTxPPiB8IE8gfCB2b2lkKTogT2JzZXJ2YWJsZTxPPiB7XG4gIGlmIChpc09ic2VydmFibGUob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH0gZWxzZSBpZiAoIW9iaikge1xuICAgIHJldHVybiBvZigpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvZihvYmogYXMgTyk7XG4gIH1cbn1cbiJdfQ==