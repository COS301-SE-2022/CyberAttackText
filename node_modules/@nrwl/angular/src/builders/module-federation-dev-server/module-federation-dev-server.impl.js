"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeModuleFederationDevServerBuilder = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const ngcli_adapter_1 = require("nx/src/adapter/ngcli-adapter");
const architect_1 = require("@angular-devkit/architect");
const path_1 = require("path");
const webpack_server_impl_1 = require("../webpack-server/webpack-server.impl");
const fs_1 = require("fs");
const project_graph_1 = require("nx/src/project-graph/project-graph");
function getDynamicRemotes(project, context, workspaceProjects) {
    // check for dynamic remotes
    // we should only check for dynamic based on what we generate
    // and fallback to empty array
    const standardPathToGeneratedMFManifestJson = (0, path_1.join)(context.workspaceRoot, project.sourceRoot, 'assets/module-federation.manifest.json');
    if (!(0, fs_1.existsSync)(standardPathToGeneratedMFManifestJson)) {
        return [];
    }
    const moduleFederationManifestJson = (0, fs_1.readFileSync)(standardPathToGeneratedMFManifestJson, 'utf-8');
    if (!moduleFederationManifestJson) {
        return [];
    }
    // This should have shape of
    // {
    //   "remoteName": "remoteLocation",
    // }
    const parsedManifest = JSON.parse(moduleFederationManifestJson);
    if (!Object.keys(parsedManifest).every((key) => typeof key === 'string' && typeof parsedManifest[key] === 'string')) {
        return [];
    }
    const dynamicRemotes = Object.entries(parsedManifest).map(([remoteName]) => remoteName);
    const invalidDynamicRemotes = dynamicRemotes.filter((remote) => !workspaceProjects[remote]);
    if (invalidDynamicRemotes.length) {
        throw new Error(invalidDynamicRemotes.length === 1
            ? `Invalid dynamic remote configured in "${standardPathToGeneratedMFManifestJson}": ${invalidDynamicRemotes[0]}.`
            : `Invalid dynamic remotes configured in "${standardPathToGeneratedMFManifestJson}": ${invalidDynamicRemotes.join(', ')}.`);
    }
    return dynamicRemotes;
}
function getStaticRemotes(project, context, workspaceProjects) {
    const mfConfigPath = (0, path_1.join)(context.workspaceRoot, project.root, 'module-federation.config.js');
    let mfeConfig;
    try {
        mfeConfig = require(mfConfigPath);
    }
    catch (_a) {
        throw new Error(`Could not load ${mfConfigPath}. Was this project generated with "@nrwl/angular:host"?`);
    }
    const staticRemotes = mfeConfig.remotes.length > 0 ? mfeConfig.remotes : [];
    const invalidStaticRemotes = staticRemotes.filter((remote) => !workspaceProjects[remote]);
    if (invalidStaticRemotes.length) {
        throw new Error(invalidStaticRemotes.length === 1
            ? `Invalid static remote configured in "${mfConfigPath}": ${invalidStaticRemotes[0]}.`
            : `Invalid static remotes configured in "${mfConfigPath}": ${invalidStaticRemotes.join(', ')}.`);
    }
    return staticRemotes;
}
function validateDevRemotes(options, workspaceProjects) {
    var _a;
    const invalidDevRemotes = (_a = options.devRemotes) === null || _a === void 0 ? void 0 : _a.filter((remote) => !workspaceProjects[remote]);
    if (invalidDevRemotes.length) {
        throw new Error(invalidDevRemotes.length === 1
            ? `Invalid dev remote provided: ${invalidDevRemotes[0]}.`
            : `Invalid dev remotes provided: ${invalidDevRemotes.join(', ')}.`);
    }
}
function executeModuleFederationDevServerBuilder(schema, context) {
    var _a, _b;
    const options = tslib_1.__rest(schema, []);
    const projectGraph = (0, devkit_1.readCachedProjectGraph)();
    const { projects: workspaceProjects } = (0, project_graph_1.readProjectsConfigurationFromProjectGraph)(projectGraph);
    const ws = new devkit_1.Workspaces(devkit_1.workspaceRoot);
    const project = workspaceProjects[context.target.project];
    validateDevRemotes(options, workspaceProjects);
    const staticRemotes = getStaticRemotes(project, context, workspaceProjects);
    const dynamicRemotes = getDynamicRemotes(project, context, workspaceProjects);
    const remotes = [...staticRemotes, ...dynamicRemotes];
    const devServeRemotes = !options.devRemotes
        ? []
        : Array.isArray(options.devRemotes)
            ? options.devRemotes
            : [options.devRemotes];
    for (const remote of remotes) {
        const isDev = devServeRemotes.includes(remote);
        const target = isDev ? 'serve' : 'serve-static';
        if (!((_a = workspaceProjects[remote].targets) === null || _a === void 0 ? void 0 : _a[target])) {
            throw new Error(`Could not find "${target}" target in "${remote}" project.`);
        }
        else if (!((_b = workspaceProjects[remote].targets) === null || _b === void 0 ? void 0 : _b[target].executor)) {
            throw new Error(`Could not find executor for "${target}" target in "${remote}" project.`);
        }
        const runOptions = {};
        if (options.verbose) {
            const [collection, executor] = workspaceProjects[remote].targets[target].executor.split(':');
            const { schema } = ws.readExecutor(collection, executor);
            if (schema.additionalProperties || 'verbose' in schema.properties) {
                runOptions.verbose = options.verbose;
            }
        }
        (0, ngcli_adapter_1.scheduleTarget)(context.workspaceRoot, {
            project: remote,
            target,
            configuration: context.target.configuration,
            runOptions,
            executor: context.builder.builderName,
        }, options.verbose).then((obs) => {
            obs.toPromise().catch((err) => {
                throw new Error(`Remote '${remote}' failed to serve correctly due to the following: \r\n${err.toString()}`);
            });
        });
    }
    return (0, webpack_server_impl_1.executeWebpackServerBuilder)(options, context);
}
exports.executeModuleFederationDevServerBuilder = executeModuleFederationDevServerBuilder;
exports.default = (0, architect_1.createBuilder)(executeModuleFederationDevServerBuilder);
//# sourceMappingURL=module-federation-dev-server.impl.js.map