"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectMigrator = void 0;
const devkit_1 = require("@nrwl/devkit");
const path_1 = require("path");
const logger_1 = require("./logger");
const validation_logging_1 = require("./validation-logging");
class ProjectMigrator {
    constructor(tree, options, targets, project, rootDir, logger) {
        var _a, _b;
        this.tree = tree;
        this.options = options;
        this.targets = targets;
        this.targetNames = {};
        this.projectConfig = project.config;
        this.project = {
            name: project.name,
            oldRoot: (_a = this.projectConfig.root) !== null && _a !== void 0 ? _a : '',
            oldSourceRoot: this.projectConfig.sourceRoot ||
                (0, devkit_1.joinPathFragments)((_b = this.projectConfig.root) !== null && _b !== void 0 ? _b : '', 'src'),
            newRoot: `${rootDir}/${project.name}`,
            newSourceRoot: `${rootDir}/${project.name}/src`,
        };
        this.logger = logger !== null && logger !== void 0 ? logger : new logger_1.Logger(this.project.name);
        this.collectTargetNames();
    }
    get projectName() {
        return this.project.name;
    }
    validate() {
        var _a, _b;
        const result = [];
        // check project root
        if (this.projectConfig.root === undefined ||
            this.projectConfig.root === null) {
            result.push({
                message: 'The project root is not defined in the project configuration.',
                hint: `Make sure the value for "projects.${this.project.name}.root" is set ` +
                    `or remove the project if it is not valid.`,
            });
        }
        else if (this.projectConfig.root !== '' &&
            !this.tree.exists(this.projectConfig.root)) {
            result.push({
                message: `The project root "${this.project.oldRoot}" could not be found.`,
                hint: `Make sure the value for "projects.${this.project.name}.root" is correct ` +
                    `or remove the project if it is not valid.`,
            });
        }
        // check project source root
        if (this.projectConfig.sourceRoot &&
            !this.tree.exists(this.projectConfig.sourceRoot)) {
            result.push({
                message: `The project source root "${this.project.oldSourceRoot}" could not be found.`,
                hint: `Make sure the value for "projects.${this.project.name}.sourceRoot" is correct ` +
                    `or remove the project if it is not valid.`,
            });
        }
        // check for usage of unsupported builders
        const allSupportedBuilders = [
            ...Object.values(this.targets)
                .map((x) => x.builders)
                .flat(),
        ];
        const unsupportedBuilders = [];
        Object.entries((_a = this.projectConfig.targets) !== null && _a !== void 0 ? _a : {}).forEach(([targetName, target]) => {
            if (!allSupportedBuilders.includes(target.executor)) {
                unsupportedBuilders.push([targetName, target.executor]);
            }
        });
        if (unsupportedBuilders.length) {
            result.push({
                messageGroup: {
                    title: 'Unsupported builders',
                    messages: unsupportedBuilders.map(([target, builder]) => `The "${target}" target is using an unsupported builder "${builder}".`),
                },
                hint: `The supported builders for ${this.projectConfig.projectType === 'library'
                    ? 'libraries'
                    : 'applications'} are: ${(0, validation_logging_1.arrayToString)(allSupportedBuilders)}.`,
            });
        }
        // check for multiple targets for the same type of target
        const targetTypes = Object.keys(this.targets);
        const targetsByType = Object.entries((_b = this.projectConfig.targets) !== null && _b !== void 0 ? _b : {}).reduce((acc, [target, { executor }]) => {
            targetTypes.forEach((targetType) => {
                if (this.targets[targetType].builders.includes(executor)) {
                    acc[targetType].push(target);
                    return acc;
                }
            });
            return acc;
        }, targetTypes.reduce((acc, targetType) => (Object.assign(Object.assign({}, acc), { [targetType]: [] })), {}));
        targetTypes.forEach((targetType) => {
            if (this.targets[targetType].acceptMultipleDefinitions ||
                targetsByType[targetType].length <= 1) {
                return;
            }
            result.push({
                message: `There is more than one target using a builder that is used to ${targetType} the project (${(0, validation_logging_1.arrayToString)(targetsByType[targetType])}).`,
                hint: `Make sure the project only has one target with a builder that is used to ${targetType} the project.`,
            });
        });
        return result.length ? result : null;
    }
    convertAsset(asset) {
        if (typeof asset === 'string') {
            return this.convertSourceRootPath(asset);
        }
        else {
            return Object.assign(Object.assign({}, asset), { input: this.convertSourceRootPath(asset.input) });
        }
    }
    convertEsLintConfigExtendToNewPath(eslintConfigPath, extendPath) {
        if (!extendPath.startsWith('..')) {
            // we only need to adjust paths that are on a different directory, files
            // in the same directory are moved together so their relative paths are
            // not changed
            return extendPath;
        }
        return (0, devkit_1.joinPathFragments)((0, devkit_1.offsetFromRoot)(this.project.newRoot), (0, path_1.dirname)(eslintConfigPath), extendPath);
    }
    convertSourceRootPath(originalPath) {
        return (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldSourceRoot))
            ? (0, devkit_1.joinPathFragments)(this.project.newSourceRoot, originalPath.replace(this.project.oldSourceRoot, ''))
            : originalPath;
    }
    convertRootPath(originalPath) {
        return (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldRoot))
            ? (0, devkit_1.joinPathFragments)(this.project.newRoot, originalPath.replace(this.project.oldRoot, ''))
            : originalPath;
    }
    convertPath(originalPath) {
        if (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldSourceRoot)) {
            return (0, devkit_1.joinPathFragments)(this.project.newSourceRoot, originalPath.replace(this.project.oldSourceRoot, ''));
        }
        if (originalPath === null || originalPath === void 0 ? void 0 : originalPath.startsWith(this.project.oldRoot)) {
            return (0, devkit_1.joinPathFragments)(this.project.newRoot, originalPath.replace(this.project.oldRoot, ''));
        }
        return originalPath;
    }
    getTargetValuesForOption(target, optionPath) {
        var _a;
        const values = new Set();
        const value = this.getValueForOption(target.options, optionPath);
        if (value) {
            values.add(value);
        }
        for (const configuration of Object.values((_a = target.configurations) !== null && _a !== void 0 ? _a : {})) {
            const value = this.getValueForOption(configuration, optionPath);
            if (value) {
                values.add(value);
            }
        }
        return Array.from(values);
    }
    getValueForOption(options, optionPath) {
        if (!options) {
            return null;
        }
        const segments = optionPath.split('.');
        let value = options;
        for (const segment of segments) {
            if (value && value[segment]) {
                value = value[segment];
            }
            else {
                return null;
            }
        }
        return value;
    }
    moveProjectRootFile(filePath, isRequired = true) {
        if (!filePath) {
            return;
        }
        const filename = !!filePath ? (0, path_1.basename)(filePath) : '';
        const from = filePath;
        const to = (0, devkit_1.joinPathFragments)(this.project.newRoot, filename);
        this.moveFile(from, to, isRequired);
    }
    moveDir(from, to) {
        (0, devkit_1.visitNotIgnoredFiles)(this.tree, from, (file) => {
            this.moveFile(file, (0, devkit_1.normalizePath)(file).replace(from, to), true);
        });
    }
    moveFile(from, to, required = true) {
        if (!this.tree.exists(from)) {
            if (required) {
                this.logger.warn(`The path "${from}" does not exist. Skipping.`);
            }
        }
        else if (this.tree.exists(to)) {
            if (required) {
                this.logger.warn(`The path "${to}" already exists. Skipping.`);
            }
        }
        else {
            const contents = this.tree.read(from);
            this.tree.write(to, contents);
            this.tree.delete(from);
        }
    }
    updateCacheableOperations(targetNames) {
        var _a;
        if (!targetNames.length) {
            return;
        }
        const workspaceConfig = (0, devkit_1.readWorkspaceConfiguration)(this.tree);
        Object.keys((_a = workspaceConfig.tasksRunnerOptions) !== null && _a !== void 0 ? _a : {}).forEach((taskRunnerName) => {
            var _a;
            const taskRunner = workspaceConfig.tasksRunnerOptions[taskRunnerName];
            taskRunner.options.cacheableOperations = Array.from(new Set([
                ...((_a = taskRunner.options.cacheableOperations) !== null && _a !== void 0 ? _a : []),
                ...targetNames,
            ]));
        });
        (0, devkit_1.updateWorkspaceConfiguration)(this.tree, workspaceConfig);
    }
    updateTsConfigFile(tsConfigPath, rootTsConfigFile, projectOffsetFromRoot) {
        (0, devkit_1.updateJson)(this.tree, tsConfigPath, (json) => {
            var _a;
            json.extends = `${projectOffsetFromRoot}${rootTsConfigFile}`;
            json.compilerOptions = (_a = json.compilerOptions) !== null && _a !== void 0 ? _a : {};
            json.compilerOptions.outDir = `${projectOffsetFromRoot}dist/out-tsc`;
            return json;
        });
    }
    collectTargetNames() {
        var _a;
        const targetTypes = Object.keys(this.targets);
        Object.entries((_a = this.projectConfig.targets) !== null && _a !== void 0 ? _a : {}).forEach(([targetName, target]) => {
            targetTypes.forEach((targetType) => {
                if (!this.targetNames[targetType] &&
                    this.targets[targetType].builders.includes(target.executor)) {
                    this.targetNames[targetType] = targetName;
                }
            });
        });
    }
}
exports.ProjectMigrator = ProjectMigrator;
//# sourceMappingURL=project.migrator.js.map