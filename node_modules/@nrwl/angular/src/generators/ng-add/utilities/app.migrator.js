"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppMigrator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const linter_1 = require("@nrwl/linter");
const generators_1 = require("@nrwl/workspace/generators");
const typescript_1 = require("@nrwl/workspace/src/utilities/typescript");
const path_1 = require("path");
const e2e_migrator_1 = require("./e2e.migrator");
const project_migrator_1 = require("./project.migrator");
const supportedTargets = {
    build: { builders: ['@angular-devkit/build-angular:browser'] },
    e2e: {
        acceptMultipleDefinitions: true,
        builders: [
            '@angular-devkit/build-angular:protractor',
            '@cypress/schematic:cypress',
        ],
    },
    i18n: { builders: ['@angular-devkit/build-angular:extract-i18n'] },
    lint: { builders: ['@angular-eslint/builder:lint'] },
    prerender: { builders: ['@nguniversal/builders:prerender'] },
    serve: { builders: ['@angular-devkit/build-angular:dev-server'] },
    server: { builders: ['@angular-devkit/build-angular:server'] },
    serveSsr: { builders: ['@nguniversal/builders:ssr-dev-server'] },
    test: { builders: ['@angular-devkit/build-angular:karma'] },
};
class AppMigrator extends project_migrator_1.ProjectMigrator {
    constructor(tree, options, project, logger) {
        var _a, _b;
        super(tree, options, supportedTargets, project, 'apps', logger);
        this.e2eMigrator = new e2e_migrator_1.E2eMigrator(tree, options, project, this.targetNames.lint);
        if (this.targetNames.lint) {
            this.oldEsLintConfigPath =
                (_b = (_a = this.projectConfig.targets[this.targetNames.lint].options) === null || _a === void 0 ? void 0 : _a.eslintConfig) !== null && _b !== void 0 ? _b : (0, devkit_1.joinPathFragments)(this.project.oldRoot, '.eslintrc.json');
            this.newEsLintConfigPath = this.convertRootPath(this.oldEsLintConfigPath);
        }
    }
    migrate() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.e2eMigrator.migrate();
            this.moveProjectFiles();
            yield this.updateProjectConfiguration();
            this.updateTsConfigs();
            this.updateEsLintConfig();
            this.updateCacheableOperations([
                this.targetNames.build,
                this.targetNames.lint,
                this.targetNames.test,
                this.targetNames.e2e,
            ].filter(Boolean));
        });
    }
    validate() {
        var _a, _b;
        const result = [
            ...((_a = super.validate()) !== null && _a !== void 0 ? _a : []),
            ...((_b = this.e2eMigrator.validate()) !== null && _b !== void 0 ? _b : []),
        ];
        return result.length ? result : null;
    }
    moveProjectFiles() {
        // project is self-contained and can be safely moved
        if (this.projectConfig.root !== '') {
            this.moveDir(this.project.oldRoot, this.project.newRoot);
            return;
        }
        // we need to pick what to move because the project is in the workspace root
        // it is not required to have a browserslist
        this.moveProjectRootFile('browserslist', false);
        this.moveProjectRootFile('.browserslistrc', false);
        if (this.targetNames.build) {
            this.moveFilePathsFromTargetToProjectRoot(this.projectConfig.targets[this.targetNames.build], ['tsConfig', 'webWorkerTsConfig', 'ngswConfigPath']);
        }
        if (this.targetNames.test) {
            this.moveFilePathsFromTargetToProjectRoot(this.projectConfig.targets[this.targetNames.test], ['karmaConfig', 'tsConfig', 'webWorkerTsConfig']);
        }
        else {
            // there could still be a karma.conf.js file in the root
            // so move to new location
            const karmaConfig = 'karma.conf.js';
            if (this.tree.exists(karmaConfig)) {
                this.logger.info('No "test" target was found, but a root Karma config file was found in the project root. The file will be moved to the new location.');
                this.moveProjectRootFile(karmaConfig);
            }
        }
        if (this.targetNames.server) {
            this.moveFilePathsFromTargetToProjectRoot(this.projectConfig.targets[this.targetNames.server], ['tsConfig']);
        }
        if (this.targetNames.lint) {
            this.moveProjectRootFile(this.oldEsLintConfigPath);
        }
        else {
            // there could still be a .eslintrc.json file in the root
            // so move to new location
            const eslintConfig = '.eslintrc.json';
            if (this.tree.exists(eslintConfig)) {
                this.logger.info('No "lint" target was found, but an ESLint config file was found in the project root. The file will be moved to the new location.');
                this.moveProjectRootFile(eslintConfig);
            }
        }
        this.moveDir(this.project.oldSourceRoot, this.project.newSourceRoot);
    }
    updateProjectConfiguration() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.projectConfig.root = this.project.newRoot;
            this.projectConfig.sourceRoot = this.project.newSourceRoot;
            if (!this.projectConfig.targets ||
                !Object.keys(this.projectConfig.targets).length) {
                this.logger.warn('The project does not have any targets configured. Skipping updating targets.');
            }
            else {
                this.updateBuildTargetConfiguration();
                this.updateLintTargetConfiguration();
                this.updateTestTargetConfiguration();
                this.updateServerTargetConfiguration();
                this.updatePrerenderTargetConfiguration();
                this.updateServeSsrTargetConfiguration();
            }
            (0, devkit_1.updateProjectConfiguration)(this.tree, this.project.name, Object.assign({}, this.projectConfig));
            yield (0, generators_1.convertToNxProjectGenerator)(this.tree, {
                project: this.project.name,
                skipFormat: true,
            });
        });
    }
    updateTsConfigs() {
        const rootTsConfigFile = (0, typescript_1.getRootTsConfigPathInTree)(this.tree);
        const projectOffsetFromRoot = (0, devkit_1.offsetFromRoot)(this.projectConfig.root);
        this.updateTsConfigFileUsedByBuildTarget(rootTsConfigFile, projectOffsetFromRoot);
        this.updateTsConfigFileUsedByTestTarget(rootTsConfigFile, projectOffsetFromRoot);
        this.updateTsConfigFileUsedByServerTarget(projectOffsetFromRoot);
    }
    updateEsLintConfig() {
        if (!this.targetNames.lint || !this.tree.exists(this.newEsLintConfigPath)) {
            return;
        }
        (0, devkit_1.updateJson)(this.tree, this.newEsLintConfigPath, (json) => {
            var _a;
            delete json.root;
            json.ignorePatterns = ['!**/*'];
            const rootEsLintConfigRelativePath = (0, devkit_1.joinPathFragments)((0, devkit_1.offsetFromRoot)(this.projectConfig.root), '.eslintrc.json');
            if (Array.isArray(json.extends)) {
                json.extends = json.extends.map((extend) => this.convertEsLintConfigExtendToNewPath(this.oldEsLintConfigPath, extend));
                // it might have not been extending from the root config, make sure it does
                if (!json.extends.includes(rootEsLintConfigRelativePath)) {
                    json.extends.unshift(rootEsLintConfigRelativePath);
                }
            }
            else {
                json.extends = rootEsLintConfigRelativePath;
            }
            (_a = json.overrides) === null || _a === void 0 ? void 0 : _a.forEach((override) => {
                var _a;
                if (!((_a = override.parserOptions) === null || _a === void 0 ? void 0 : _a.project)) {
                    return;
                }
                override.parserOptions.project = [
                    `${this.projectConfig.root}/tsconfig.*?.json`,
                ];
            });
            return json;
        });
    }
    convertBuildOptions(buildOptions) {
        buildOptions.outputPath =
            buildOptions.outputPath &&
                (0, devkit_1.joinPathFragments)('dist', this.project.newRoot, this.targetNames.server ? 'browser' : '');
        buildOptions.index =
            buildOptions.index && this.convertAsset(buildOptions.index);
        buildOptions.main =
            buildOptions.main && this.convertAsset(buildOptions.main);
        buildOptions.polyfills =
            buildOptions.polyfills && this.convertAsset(buildOptions.polyfills);
        buildOptions.tsConfig =
            buildOptions.tsConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(buildOptions.tsConfig));
        buildOptions.assets =
            buildOptions.assets &&
                buildOptions.assets.map((asset) => this.convertAsset(asset));
        buildOptions.styles =
            buildOptions.styles &&
                buildOptions.styles.map((style) => this.convertAsset(style));
        buildOptions.scripts =
            buildOptions.scripts &&
                buildOptions.scripts.map((script) => this.convertAsset(script));
        buildOptions.fileReplacements =
            buildOptions.fileReplacements &&
                buildOptions.fileReplacements.map((replacement) => ({
                    replace: this.convertAsset(replacement.replace),
                    with: this.convertAsset(replacement.with),
                }));
    }
    convertServerOptions(serverOptions) {
        serverOptions.outputPath =
            serverOptions.outputPath &&
                (0, devkit_1.joinPathFragments)('dist', this.project.newRoot, 'server');
        serverOptions.main =
            serverOptions.main && this.convertPath(serverOptions.main);
        serverOptions.tsConfig =
            serverOptions.tsConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(serverOptions.tsConfig));
        serverOptions.fileReplacements =
            serverOptions.fileReplacements &&
                serverOptions.fileReplacements.map((replacement) => ({
                    replace: this.convertAsset(replacement.replace),
                    with: this.convertAsset(replacement.with),
                }));
    }
    moveFilePathsFromTargetToProjectRoot(target, options) {
        options.forEach((option) => {
            this.getTargetValuesForOption(target, option).forEach((path) => {
                this.moveProjectRootFile(path);
            });
        });
    }
    updateBuildTargetConfiguration() {
        var _a, _b, _c, _d, _e, _f;
        if (!this.targetNames.build) {
            this.logger.warn('There is no build target in the project configuration. Skipping updating the build target configuration.');
            return;
        }
        const buildTarget = this.projectConfig.targets[this.targetNames.build];
        if (!buildTarget.options &&
            (!buildTarget.configurations ||
                !Object.keys(buildTarget.configurations).length)) {
            this.logger.warn(`The target "${this.targetNames.build}" is not specifying any options or configurations. Skipping updating the target configuration.`);
            return;
        }
        const buildDevTsConfig = (_b = (_a = buildTarget.options) === null || _a === void 0 ? void 0 : _a.tsConfig) !== null && _b !== void 0 ? _b : (_d = (_c = buildTarget.configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? void 0 : _d.tsConfig;
        if (!buildDevTsConfig) {
            this.logger.warn(`The "${this.targetNames.build}" target does not have the "tsConfig" option configured. Skipping updating the tsConfig file.`);
        }
        else {
            const newBuildDevTsConfig = this.convertPath(buildDevTsConfig);
            if (!this.tree.exists(newBuildDevTsConfig)) {
                this.logger.warn(`The tsConfig file "${buildDevTsConfig}" specified in the "${this.targetNames.build}" target could not be found. Skipping updating the tsConfig file.`);
            }
        }
        this.convertBuildOptions((_e = buildTarget.options) !== null && _e !== void 0 ? _e : {});
        Object.values((_f = buildTarget.configurations) !== null && _f !== void 0 ? _f : {}).forEach((config) => this.convertBuildOptions(config));
    }
    updateLintTargetConfiguration() {
        if (!this.targetNames.lint) {
            return;
        }
        this.projectConfig.targets[this.targetNames.lint].executor =
            '@nrwl/linter:eslint';
        const lintOptions = this.projectConfig.targets[this.targetNames.lint].options;
        if (!lintOptions) {
            this.logger.warn(`The target "${this.targetNames.lint}" is not specifying any options. Skipping updating the target configuration.`);
            return;
        }
        const existEsLintConfigPath = this.tree.exists(this.newEsLintConfigPath);
        if (!existEsLintConfigPath) {
            this.logger.warn(`The ESLint config file "${this.oldEsLintConfigPath}" could not be found. Skipping updating the file.`);
        }
        lintOptions.eslintConfig =
            lintOptions.eslintConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(lintOptions.eslintConfig));
        lintOptions.lintFilePatterns =
            lintOptions.lintFilePatterns &&
                lintOptions.lintFilePatterns.map((pattern) => {
                    // replace the old source root with the new root, we want to lint all
                    // matching files in the project, not just the ones in the source root
                    if (pattern.startsWith(this.project.oldSourceRoot)) {
                        return (0, devkit_1.joinPathFragments)(this.project.newRoot, pattern.replace(this.project.oldSourceRoot, ''));
                    }
                    // replace the old root with the new root
                    if (pattern.startsWith(this.project.oldRoot)) {
                        return (0, devkit_1.joinPathFragments)(this.project.newRoot, pattern.replace(this.project.oldRoot, ''));
                    }
                    // do nothing, warn about the pattern
                    this.logger.warn(`The lint file pattern "${pattern}" specified in the "${this.targetNames.lint}" target is not contained in the project root or source root. The pattern will not be updated.`);
                    return pattern;
                });
        if (!existEsLintConfigPath) {
            return;
        }
        const eslintConfig = (0, devkit_1.readJson)(this.tree, this.newEsLintConfigPath);
        if ((0, linter_1.hasRulesRequiringTypeChecking)(eslintConfig)) {
            lintOptions.hasTypeAwareRules = true;
        }
    }
    updatePrerenderTargetConfiguration() {
        if (!this.targetNames.prerender) {
            return;
        }
        const prerenderTarget = this.projectConfig.targets[this.targetNames.prerender];
        if (!prerenderTarget.options) {
            this.logger.warn(`The target "${this.targetNames.prerender}" is not specifying any options. Skipping updating the target configuration.`);
            return;
        }
        prerenderTarget.options.routesFile =
            prerenderTarget.options.routesFile &&
                this.convertPath(prerenderTarget.options.routesFile);
    }
    updateServerTargetConfiguration() {
        var _a, _b, _c, _d, _e, _f;
        if (!this.targetNames.server) {
            return;
        }
        const serverTarget = this.projectConfig.targets[this.targetNames.server];
        if (!serverTarget.options &&
            (!serverTarget.configurations ||
                !Object.keys(serverTarget.configurations).length)) {
            this.logger.warn(`The target "${this.targetNames.server}" is not specifying any options or configurations. Skipping updating the target configuration.`);
            return;
        }
        const serverDevTsConfig = (_b = (_a = serverTarget.options) === null || _a === void 0 ? void 0 : _a.tsConfig) !== null && _b !== void 0 ? _b : (_d = (_c = serverTarget.configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? void 0 : _d.tsConfig;
        if (!serverDevTsConfig) {
            this.logger.warn(`The "${this.targetNames.server}" target does not have the "tsConfig" option configured. Skipping updating the tsConfig file.`);
        }
        else {
            const newServerDevTsConfig = this.convertPath(serverDevTsConfig);
            if (!this.tree.exists(newServerDevTsConfig)) {
                this.logger.warn(`The tsConfig file "${serverDevTsConfig}" specified in the "${this.targetNames.server}" target could not be found. Skipping updating the tsConfig file.`);
            }
        }
        this.convertServerOptions((_e = serverTarget.options) !== null && _e !== void 0 ? _e : {});
        Object.values((_f = serverTarget.configurations) !== null && _f !== void 0 ? _f : {}).forEach((config) => this.convertServerOptions(config));
    }
    updateServeSsrTargetConfiguration() {
        if (!this.targetNames.serveSsr) {
            return;
        }
        const serveSsrTarget = this.projectConfig.targets[this.targetNames.serveSsr];
        if (!serveSsrTarget.options &&
            (!serveSsrTarget.configurations ||
                !Object.keys(serveSsrTarget.configurations).length)) {
            this.logger.warn(`The target "${this.targetNames.serveSsr}" is not specifying any options or configurations. Skipping updating the target configuration.`);
            return;
        }
        ['sslKey', 'sslCert', 'proxyConfig'].forEach((option) => {
            var _a;
            if (serveSsrTarget.options) {
                serveSsrTarget.options[option] =
                    serveSsrTarget.options[option] &&
                        this.convertPath(serveSsrTarget.options[option]);
            }
            for (const configuration of Object.values((_a = serveSsrTarget.configurations) !== null && _a !== void 0 ? _a : {})) {
                serveSsrTarget.configurations[configuration][option] =
                    serveSsrTarget.configurations[configuration][option] &&
                        this.convertPath(serveSsrTarget.configurations[configuration][option]);
            }
        });
    }
    updateTestTargetConfiguration() {
        if (!this.targetNames.test) {
            return;
        }
        const testOptions = this.projectConfig.targets[this.targetNames.test].options;
        if (!testOptions) {
            this.logger.warn(`The target "${this.targetNames.test}" is not specifying any options. Skipping updating the target configuration.`);
            return;
        }
        if (!testOptions.tsConfig) {
            this.logger.warn(`The "${this.targetNames.test}" target does not have the "tsConfig" option configured. Skipping updating the tsConfig file.`);
        }
        else {
            const newTestTsConfig = this.convertPath(testOptions.tsConfig);
            if (!this.tree.exists(newTestTsConfig)) {
                this.logger.warn(`The tsConfig file "${testOptions.tsConfig}" specified in the "${this.targetNames.test}" target could not be found. Skipping updating the tsConfig file.`);
            }
        }
        testOptions.main = testOptions.main && this.convertAsset(testOptions.main);
        testOptions.polyfills =
            testOptions.polyfills && this.convertAsset(testOptions.polyfills);
        testOptions.tsConfig =
            testOptions.tsConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(testOptions.tsConfig));
        testOptions.karmaConfig =
            testOptions.karmaConfig &&
                (0, devkit_1.joinPathFragments)(this.project.newRoot, (0, path_1.basename)(testOptions.karmaConfig));
        testOptions.assets =
            testOptions.assets &&
                testOptions.assets.map((asset) => this.convertAsset(asset));
        testOptions.styles =
            testOptions.styles &&
                testOptions.styles.map((style) => this.convertAsset(style));
        testOptions.scripts =
            testOptions.scripts &&
                testOptions.scripts.map((script) => this.convertAsset(script));
    }
    updateTsConfigFileUsedByBuildTarget(rootTsConfigFile, projectOffsetFromRoot) {
        var _a, _b, _c, _d;
        if (!this.targetNames.build) {
            return;
        }
        const tsConfigPath = (_b = (_a = this.projectConfig.targets[this.targetNames.build].options) === null || _a === void 0 ? void 0 : _a.tsConfig) !== null && _b !== void 0 ? _b : (_d = (_c = this.projectConfig.targets[this.targetNames.build].configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? void 0 : _d.tsConfig;
        if (!tsConfigPath || !this.tree.exists(tsConfigPath)) {
            // we already logged a warning for these cases, so just return
            return;
        }
        this.updateTsConfigFile(tsConfigPath, rootTsConfigFile, projectOffsetFromRoot);
    }
    updateTsConfigFileUsedByServerTarget(projectOffsetFromRoot) {
        var _a, _b, _c, _d;
        if (!this.targetNames.server) {
            return;
        }
        const tsConfigPath = (_b = (_a = this.projectConfig.targets[this.targetNames.server].options) === null || _a === void 0 ? void 0 : _a.tsConfig) !== null && _b !== void 0 ? _b : (_d = (_c = this.projectConfig.targets[this.targetNames.server].configurations) === null || _c === void 0 ? void 0 : _c.development) === null || _d === void 0 ? void 0 : _d.tsConfig;
        if (!tsConfigPath || !this.tree.exists(tsConfigPath)) {
            // we already logged a warning for these cases, so just return
            return;
        }
        (0, devkit_1.updateJson)(this.tree, tsConfigPath, (json) => {
            var _a;
            json.compilerOptions = (_a = json.compilerOptions) !== null && _a !== void 0 ? _a : {};
            json.compilerOptions.outDir = `${projectOffsetFromRoot}dist/out-tsc`;
            return json;
        });
    }
    updateTsConfigFileUsedByTestTarget(rootTsConfigFile, projectOffsetFromRoot) {
        var _a;
        if (!this.targetNames.test) {
            return;
        }
        const tsConfig = (_a = this.projectConfig.targets[this.targetNames.test].options) === null || _a === void 0 ? void 0 : _a.tsConfig;
        if (!tsConfig || !this.tree.exists(tsConfig)) {
            // we already logged a warning for these cases, so just return
            return;
        }
        this.updateTsConfigFile(tsConfig, rootTsConfigFile, projectOffsetFromRoot);
    }
}
exports.AppMigrator = AppMigrator;
//# sourceMappingURL=app.migrator.js.map