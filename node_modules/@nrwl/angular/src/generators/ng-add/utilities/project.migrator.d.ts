import { ProjectConfiguration, TargetConfiguration, Tree } from '@nrwl/devkit';
import { GeneratorOptions } from '../schema';
import { Logger } from './logger';
import { MigrationProjectConfiguration, Target, ValidationResult } from './types';
export declare abstract class ProjectMigrator<TargetType extends string = any> {
    protected readonly tree: Tree;
    protected readonly options: GeneratorOptions;
    protected readonly targets: Record<TargetType, Target>;
    get projectName(): string;
    protected projectConfig: ProjectConfiguration;
    protected project: {
        name: string;
        oldRoot: string;
        oldSourceRoot: string;
        newRoot: string;
        newSourceRoot: string;
    };
    protected logger: Logger;
    protected readonly targetNames: Partial<Record<TargetType, string>>;
    constructor(tree: Tree, options: GeneratorOptions, targets: Record<TargetType, Target>, project: MigrationProjectConfiguration, rootDir: string, logger?: Logger);
    abstract migrate(): Promise<void>;
    validate(): ValidationResult;
    protected convertAsset(asset: string | any): string | any;
    protected convertEsLintConfigExtendToNewPath(eslintConfigPath: string, extendPath: string): string;
    protected convertSourceRootPath(originalPath: string): string;
    protected convertRootPath(originalPath: string): string;
    protected convertPath(originalPath: string): string;
    protected getTargetValuesForOption(target: TargetConfiguration, optionPath: string): any[];
    protected getValueForOption(options: Record<string, any> | undefined, optionPath: string): any;
    protected moveProjectRootFile(filePath: string, isRequired?: boolean): void;
    protected moveDir(from: string, to: string): void;
    protected moveFile(from: string, to: string, required?: boolean): void;
    protected updateCacheableOperations(targetNames: string[]): void;
    protected updateTsConfigFile(tsConfigPath: string, rootTsConfigFile: string, projectOffsetFromRoot: string): void;
    private collectTargetNames;
}
