"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addRemoteToHost = exports.checkIsCommaNeeded = void 0;
const devkit_1 = require("@nrwl/devkit");
const tsquery_1 = require("@phenomnomnominal/tsquery");
const ts = require("typescript");
const ast_utils_1 = require("../../../utils/nx-devkit/ast-utils");
const ast_utils_2 = require("@nrwl/workspace/src/utilities/ast-utils");
const standalone_utils_1 = require("../../../utils/nx-devkit/standalone-utils");
function checkIsCommaNeeded(mfRemoteText) {
    const remoteText = mfRemoteText.replace(/\s+/g, '');
    return !remoteText.endsWith(',]')
        ? remoteText === '[]'
            ? false
            : true
        : false;
}
exports.checkIsCommaNeeded = checkIsCommaNeeded;
function addRemoteToHost(tree, options) {
    if (options.mfType === 'remote' && options.host) {
        const hostProject = (0, devkit_1.readProjectConfiguration)(tree, options.host);
        const pathToMFManifest = (0, devkit_1.joinPathFragments)(hostProject.sourceRoot, 'assets/module-federation.manifest.json');
        const hostFederationType = determineHostFederationType(tree, pathToMFManifest);
        if (hostFederationType === 'static') {
            addRemoteToStaticHost(tree, options, hostProject);
        }
        else if (hostFederationType === 'dynamic') {
            addRemoteToDynamicHost(tree, options, pathToMFManifest);
        }
        const declarationFilePath = (0, devkit_1.joinPathFragments)(hostProject.sourceRoot, 'remotes.d.ts');
        const declarationFileContent = (tree.exists(declarationFilePath)
            ? tree.read(declarationFilePath, 'utf-8')
            : '') +
            `\ndeclare module '${options.appName}/${options.standalone ? `Routes` : `Module`}';`;
        tree.write(declarationFilePath, declarationFileContent);
        addLazyLoadedRouteToHostAppModule(tree, options, hostFederationType);
    }
}
exports.addRemoteToHost = addRemoteToHost;
function determineHostFederationType(tree, pathToMfManifest) {
    return tree.exists(pathToMfManifest) ? 'dynamic' : 'static';
}
function addRemoteToStaticHost(tree, options, hostProject) {
    const hostMFConfigPath = (0, devkit_1.joinPathFragments)(hostProject.root, 'module-federation.config.js');
    if (!hostMFConfigPath || !tree.exists(hostMFConfigPath)) {
        throw new Error(`The selected host application, ${options.host}, does not contain a module-federation.config.js or module-federation.manifest.json file. Are you sure it has been set up as a host application?`);
    }
    const hostMFConfig = tree.read(hostMFConfigPath, 'utf-8');
    const webpackAst = tsquery_1.tsquery.ast(hostMFConfig);
    const mfRemotesNode = (0, tsquery_1.tsquery)(webpackAst, 'Identifier[name=remotes] ~ ArrayLiteralExpression', { visitAllChildren: true })[0];
    const endOfPropertiesPos = mfRemotesNode.getEnd() - 1;
    const isCommaNeeded = checkIsCommaNeeded(mfRemotesNode.getText());
    const updatedConfig = `${hostMFConfig.slice(0, endOfPropertiesPos)}${isCommaNeeded ? ',' : ''}'${options.appName}',${hostMFConfig.slice(endOfPropertiesPos)}`;
    tree.write(hostMFConfigPath, updatedConfig);
}
function addRemoteToDynamicHost(tree, options, pathToMfManifest) {
    (0, devkit_1.updateJson)(tree, pathToMfManifest, (manifest) => {
        return Object.assign(Object.assign({}, manifest), { [options.appName]: `http://localhost:${options.port}` });
    });
}
// TODO(colum): future work: allow dev to pass to path to routing module
function addLazyLoadedRouteToHostAppModule(tree, options, hostFederationType) {
    const hostAppConfig = (0, devkit_1.readProjectConfiguration)(tree, options.host);
    const isHostStandalone = !tree
        .read((0, devkit_1.joinPathFragments)(hostAppConfig.sourceRoot, 'bootstrap.ts'), 'utf-8')
        .includes('bootstrapModule');
    const pathToHostRootRouting = isHostStandalone
        ? `${hostAppConfig.sourceRoot}/bootstrap.ts`
        : `${hostAppConfig.sourceRoot}/app/app.module.ts`;
    if (!tree.exists(pathToHostRootRouting)) {
        return;
    }
    const hostRootRoutingFile = tree.read(pathToHostRootRouting, 'utf-8');
    if (!hostRootRoutingFile.includes('RouterModule.forRoot(')) {
        return;
    }
    let sourceFile = ts.createSourceFile(pathToHostRootRouting, hostRootRoutingFile, ts.ScriptTarget.Latest, true);
    if (hostFederationType === 'dynamic') {
        sourceFile = (0, ast_utils_2.insertImport)(tree, sourceFile, pathToHostRootRouting, 'loadRemoteModule', '@nrwl/angular/mf');
    }
    const routePathName = options.standalone ? 'Routes' : 'Module';
    const routeToAdd = hostFederationType === 'dynamic'
        ? `loadRemoteModule('${options.appName}', './${routePathName}')`
        : `import('${options.appName}/${routePathName}')`;
    if (hostRootRoutingFile.includes('@NgModule')) {
        sourceFile = (0, ast_utils_1.addRoute)(tree, pathToHostRootRouting, sourceFile, `{
         path: '${options.appName}', 
         loadChildren: () => ${routeToAdd}.then(m => m.RemoteEntryModule)
     }`);
    }
    else {
        (0, standalone_utils_1.addStandaloneRoute)(tree, pathToHostRootRouting, `{
    path: '${options.appName}',
    loadChildren: () => ${routeToAdd}.then(m => m.RemoteRoutes)
    }`);
    }
    const pathToAppComponentTemplate = (0, devkit_1.joinPathFragments)(hostAppConfig.sourceRoot, 'app/app.component.html');
    const appComponent = tree.read(pathToAppComponentTemplate, 'utf-8');
    if (appComponent.includes(`<ul class="remote-menu">`) &&
        appComponent.includes('</ul>')) {
        const indexOfClosingMenuTag = appComponent.indexOf('</ul>');
        const newAppComponent = `${appComponent.slice(0, indexOfClosingMenuTag)}<li><a routerLink='${options.appName}'>${(0, devkit_1.names)(options.appName).className}</a></li>\n${appComponent.slice(indexOfClosingMenuTag)}`;
        tree.write(pathToAppComponentTemplate, newAppComponent);
    }
}
//# sourceMappingURL=add-remote-to-host.js.map