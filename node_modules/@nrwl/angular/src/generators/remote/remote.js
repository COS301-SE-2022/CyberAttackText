"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const application_1 = require("../application/application");
const get_mf_projects_1 = require("../../utils/get-mf-projects");
const project_1 = require("../utils/project");
const setup_mf_1 = require("../setup-mf/setup-mf");
function findNextAvailablePort(tree) {
    var _a, _b, _c;
    const mfProjects = (0, get_mf_projects_1.getMFProjects)(tree);
    const ports = new Set([4200]);
    for (const mfProject of mfProjects) {
        const { targets } = (0, devkit_1.readProjectConfiguration)(tree, mfProject);
        const port = (_c = (_b = (_a = targets === null || targets === void 0 ? void 0 : targets.serve) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.port) !== null && _c !== void 0 ? _c : 4200;
        ports.add(port);
    }
    const nextAvailablePort = Math.max(...ports) + 1;
    return nextAvailablePort;
}
function remote(tree, options) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const projects = (0, devkit_1.getProjects)(tree);
        if (options.host && !projects.has(options.host)) {
            throw new Error(`The name of the application to be used as the host app does not exist. (${options.host})`);
        }
        const appName = (0, project_1.normalizeProjectName)(options.name, options.directory);
        const port = (_a = options.port) !== null && _a !== void 0 ? _a : findNextAvailablePort(tree);
        const installTask = yield (0, application_1.default)(tree, Object.assign(Object.assign({}, options), { routing: true, skipDefaultProject: true, port }));
        yield (0, setup_mf_1.setupMf)(tree, {
            appName,
            mfType: 'remote',
            routing: true,
            host: options.host,
            port,
            skipPackageJson: options.skipPackageJson,
            skipFormat: true,
            e2eProjectName: `${appName}-e2e`,
            standalone: options.standalone,
        });
        removeDeadCode(tree, options);
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(tree);
        }
        return installTask;
    });
}
exports.default = remote;
function removeDeadCode(tree, options) {
    const projectName = (0, project_1.normalizeProjectName)(options.name, options.directory);
    const project = (0, devkit_1.readProjectConfiguration)(tree, projectName);
    ['css', 'less', 'scss', 'sass'].forEach((style) => {
        const pathToComponentStyle = (0, devkit_1.joinPathFragments)(project.sourceRoot, `app/app.component.${style}`);
        if (tree.exists(pathToComponentStyle)) {
            tree.delete(pathToComponentStyle);
        }
    });
    tree.rename((0, devkit_1.joinPathFragments)(project.sourceRoot, 'app/nx-welcome.component.ts'), (0, devkit_1.joinPathFragments)(project.sourceRoot, 'app/remote-entry/nx-welcome.component.ts'));
    tree.delete((0, devkit_1.joinPathFragments)(project.sourceRoot, 'app/app.component.spec.ts'));
    tree.delete((0, devkit_1.joinPathFragments)(project.sourceRoot, 'app/app.component.html'));
    const pathToAppComponent = (0, devkit_1.joinPathFragments)(project.sourceRoot, 'app/app.component.ts');
    if (!options.standalone) {
        const component = tree.read(pathToAppComponent, 'utf-8').split('templateUrl')[0] +
            `template: '<router-outlet></router-outlet>'
})
export class AppComponent {}`;
        tree.write(pathToAppComponent, component);
        tree.write((0, devkit_1.joinPathFragments)(project.sourceRoot, 'app/app.module.ts'), `import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { RouterModule } from '@angular/router';
import { AppComponent } from './app.component';

@NgModule({
 declarations: [AppComponent],
 imports: [
   BrowserModule,
   RouterModule.forRoot([{
     path: '',
     loadChildren: () => import('./remote-entry/entry.module').then(m => m.RemoteEntryModule)
   }], { initialNavigation: 'enabledBlocking' }),
 ],
 providers: [],
 bootstrap: [AppComponent],
})
export class AppModule {}`);
    }
    else {
        tree.delete(pathToAppComponent);
    }
}
//# sourceMappingURL=remote.js.map