"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.respondWithErrorAndExit = exports.respondToClient = exports.resetInactivityTimeout = exports.handleServerProcessTermination = exports.SERVER_INACTIVITY_TIMEOUT_MS = void 0;
const tslib_1 = require("tslib");
const workspace_root_1 = require("../../utils/workspace-root");
const logger_1 = require("./logger");
const socket_utils_1 = require("nx/src/daemon/socket-utils");
exports.SERVER_INACTIVITY_TIMEOUT_MS = 10800000; // 10800000 ms = 3 hours
function handleServerProcessTermination({ server, reason, watcherSubscription, }) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            server.close();
            if (watcherSubscription) {
                yield watcherSubscription.unsubscribe();
                logger_1.serverLogger.watcherLog(`Unsubscribed from changes within: ${workspace_root_1.workspaceRoot}`);
            }
            logger_1.serverLogger.log(`Server stopped because: "${reason}"`);
        }
        finally {
            process.exit(0);
        }
    });
}
exports.handleServerProcessTermination = handleServerProcessTermination;
let serverInactivityTimerId;
function resetInactivityTimeout(cb) {
    if (serverInactivityTimerId) {
        clearTimeout(serverInactivityTimerId);
    }
    serverInactivityTimerId = setTimeout(cb, exports.SERVER_INACTIVITY_TIMEOUT_MS);
}
exports.resetInactivityTimeout = resetInactivityTimeout;
function respondToClient(socket, response, description) {
    return new Promise((res) => {
        socket.write(response, () => {
            if (description) {
                logger_1.serverLogger.requestLog(`Responding to the client.`, description);
            }
            // Close the connection once all data has been written so that the client knows when to read it.
            socket.end();
            logger_1.serverLogger.log(`Closed Connection to Client`);
            res(null);
        });
    });
}
exports.respondToClient = respondToClient;
function respondWithErrorAndExit(socket, description, error) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        // print some extra stuff in the error message
        logger_1.serverLogger.requestLog(`Responding to the client with an error.`, description, error.message);
        console.error(error);
        error.message = `${error.message}\n\nBecause of the error the Nx daemon process has exited. The next Nx command is going to restart the daemon process.\nIf the error persists, please run "nx reset".`;
        yield respondToClient(socket, (0, socket_utils_1.serializeResult)(error, null), null);
        process.exit(1);
    });
}
exports.respondWithErrorAndExit = respondWithErrorAndExit;
//# sourceMappingURL=shutdown-utils.js.map